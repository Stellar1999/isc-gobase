package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
package test

import (
	"github.com/isyscore/isc-gobase/compress"
	"github.com/isyscore/isc-gobase/file"
	"github.com/isyscore/isc-gobase/isc"
	"testing"
)

func TestGZip(t *testing.T) {
	str := []byte("Hello World!")
	if b, err := compress.GzipCompress(str); err == nil {
		t.Logf("%v", b)
	} else {
		t.Logf("GzipCompress err: %v", err)
	}
}

func TestUnGzip(t *testing.T) {
	b := []byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xff, 0xf2, 0x48, 0xcd, 0xc9, 0xc9, 0x57,
		0x08, 0xcf, 0x2f, 0xca, 0x49, 0x51, 0x04, 0x00,
		0x00, 0x00, 0xff, 0xff}
	if s, err := compress.GzipDecompress(b); err == nil {
		t.Logf("%s", string(s))
	} else {
		t.Logf("GzipDecompress err: %v", err)
	}
}

func TestZip(t *testing.T) {
	dest := "./zip/test.zip"
	srcSize := isc.FormatSize(file.Sizes("./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"))
	if err := compress.Zip(dest, "./zip/test.zip", "./zip/test1.txt", "./zip/test2.txt", "./zip/test3.txt"); err == nil {
		dstSize := isc.FormatSize(file.Size("./zip/test.zip"))
		t.Logf("Compress success, size: %s -> %s", srcSize, dstSize)
	} else {
		t.Logf("Compress err: %v", err)
	}
}

func TestUnzip(t *testing.T) {
	zf := "./zip/test.zip"
	dest := "./zip/uncomp"
	err := compress.Unzip(zf, dest)
	if err == nil {
		t.Logf("Decompress success")
	} else {
		t.Logf("Decompress err: %v", err)
	}
}
